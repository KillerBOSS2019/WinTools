import os
import subprocess
from sys import platform
from ast import literal_eval
import sounddevice as sd
import pyttsx3



"""
Screenshot is working, doesnt appear to be copying an image to clipbord anylonger?  
need to double check this is fact
Also need to find a module to replace mss.tools import which saves an RGB data to a file
"""
### Screenshot Monitor Imports ###
from screeninfo import get_monitors
from PIL import Image
from io import BytesIO
import os


if platform == "win32":
    from ctypes import windll
    import audio2numpy as a2n
  #  import mss.tools # used for screenshots, need to find another module for this
    import win32clipboard


def runWindowsCMD(command):
    systemencoding = windll.kernel32.GetConsoleOutputCP()
    systemencoding= f"cp{systemencoding}"
    output = subprocess.run(command, stdout=subprocess.PIPE, shell=True)
    result = str(output.stdout.decode(systemencoding))
    return result

class SystemPrograms:
    def __init__(self):
        self.programs = self.getSystemApp()
        self.steam = self.programs["SteamApps"]
        self.microsoft = self.programs['Microsoft']
        self.other = self.programs["OtherApps"]

    def getSystemApp(self):
        SteamsApps = {}
        OtherApps = {}
        Microsoft = {}

        programs = runWindowsCMD(["powershell", "get-StartApps | ConvertTo-Json"])
        programs = list(literal_eval(programs))

        for program in programs:
            if not program['Name'].lower() in ["readme", "documentation"]:
                if "steam://rungameid/" in program['AppID']:
                    SteamsApps[program['Name']] = program['AppID']
                elif "Microsoft." in program['AppID'] and ".AutoGenerated." not in program['AppID']:
                    Microsoft[program['Name']] = program['AppID']
                else:
                    OtherApps[program['Name']] = program['AppID']
        return {"SteamApps": SteamsApps, "Microsoft": Microsoft, "OtherApps": OtherApps}

    def start(self, appName, apptype):
        if self.programs[apptype].get(appName, False):
            runWindowsCMD("explorer shell:appsfolder\\" + self.programs[apptype][appName])




class Powerplan:
    def __init__(self):
        self.currentPPlan = {}
        self.powerplans = {}
        self.GetPowerplan()

    def GetPowerplan(self):
        powerplanResult = runWindowsCMD("powercfg -List")
        powerplanDict = {}

        for powerplan in powerplanResult.split("\n"):
            if ":" in powerplan:
                parsedData = powerplan.split(":")[1].split() # from "Power Scheme GUID: 381b4222-f694-41f0-9685-ff5bb260df2e  (Balanced) *" to ["381b4222-f694-41f0-9685-ff5bb260df2e", "(Balanced) *"]
                the_data = (parsedData[0])
                plan_name = (" ".join(parsedData[1:]))

                if "*" in plan_name:
                    plan_name = plan_name[plan_name.find("(") + 1: plan_name.find(")")]
                    self.powerplans[plan_name]=the_data

                    self.currentPPlan[plan_name]=the_data
                else:
                    plan_name = plan_name[plan_name.find("(") + 1: plan_name.find(")")]
                    self.powerplans[plan_name]=the_data
    
    def changeTo(self, pplanName):
        if self.powerplans.get(pplanName, False):
            runWindowsCMD(f"powercfg.exe /S {self.powerplans[pplanName]}")
            return True
        return False

def getAllVoices():
    engine = pyttsx3.init()
    return engine.getProperty('voices')

def getAllOutput_TTS2():
    audio_dict = {}
    for outputDevice in sd.query_hostapis(0)['devices']:
        if sd.query_devices(outputDevice)['max_output_channels'] > 0:
            audio_dict[sd.query_devices(device=outputDevice)['name']] = sd.query_devices(device=outputDevice)['default_samplerate']
    return audio_dict

def TextToSpeech(message, voicesChoics, volume=100, rate=100, output="Default"):
    engine = pyttsx3.init()
    voices = engine.getProperty('voices')
    engine.setProperty("volume", volume/100)
    engine.setProperty("rate", rate)
    for voice in voices:
        if voice.name == voicesChoics:
            engine.setProperty('voice', voice.id)
            print("Using", voice.name, "voices", voice)

    if output == "Default":
        engine.say(message)
    else:
        appdata = os.getenv('APPDATA')
        engine.save_to_file(message, rf"{appdata}/TouchPortal/Plugins/WinTools/speech.wav")
    engine.runAndWait()
    engine.stop()

    if output is not "Default":
        device = getAllOutput_TTS2()  ### can make this list returned a global + save that will pull it once and thats it?  instead of every time this action is called..which could be troublesome..
        sd.default.samplerate = device[output]
        sd.default.device = output +", MME"
        x,sr=a2n.audio_from_file(rf"{appdata}/TouchPortal/Plugins/WinTools/speech.wav")
        sd.play(x, sr, blocking=True)
        
        




class ScreenShot:
    def screenshot_monitor(self, 
                           monitor_number,
                           filename=None,
                           clipboard = False):
        
        ### Taking the User input of "Monitor:1 for example" and converting it to the correct monitor number
        monitor_number = int(monitor_number.split(":")[0])
        with mss.mss() as sct:
            try:
                mon = sct.monitors[monitor_number]  
                monitor = {
                    "top": mon["top"],
                    "left": mon["left"],
                    "width": mon["width"],
                    "height": mon["height"],
                    "mon": monitor_number,
                }
                
                # Grab the Image
                sct_img = sct.grab(monitor)     

                if clipboard == True:
                    if monitor_number == 0:
                        # Monitor 0 is ALL Monitors Combined, we need to save this to temp file and then to clipboard
                        
                        image = Image.frombytes('RGB', (sct_img.width, sct_img.height), sct_img.rgb, 'raw', 'RGB', 0, 1)
                        image.save("temp.png")



                        
                        # Converting to Bytes then off to Clipboard
                        self.all_monitors_bytes_to_clipboard("temp.png")

                    elif monitor_number != 0:
                        # Instead of making a temp file we get it direct from raw to clipboard
                        img = Image.frombytes("RGB", sct_img.size, sct_img.bgra, "raw", "BGRX")
                        
                        ClipBoard.copy_image_to_clipboard(img)
                       # TPClient.stateUpdate("KillerBOSS.TP.Plugins.winsettings.winsettings.publicIP", getFrame_base64(img).decode())

                if clipboard == False:
                    image = Image.frombytes('RGB', (sct_img.width, sct_img.height), sct_img.rgb, 'raw', 'RGB', 0, 1)
                    image.save(filename + ".png")

                    print("Image saved -> "+ filename+ ".png" )

            except IndexError:
                print("[ERROR] This Monitor does not exist")
                


    def all_monitors_bytes_to_clipboard(self, filepath):
        """
        Converting an Image to Bytes to Copy to Clipboard
        """

        image = Image.open(filepath)
        output = BytesIO()
        image.convert("RGB").save(output, "BMP")
        data = output.getvalue()[14:]
        output.close()

        if platform=="win32":
            ### Sending to Clipboard
            ClipBoard.send_to_clipboard(win32clipboard.CF_DIB, data)
            ### Deleting Temp File
            os.remove(filepath)





class ClipBoard:
    
    def copy_image_to_clipboard(image):
        if platform == "win32":
            bio = BytesIO()
            image.save(bio, 'BMP')
            data = bio.getvalue()[14:] # removing some headers
            bio.close()
            ClipBoard.send_to_clipboard(win32clipboard.CF_DIB, data)
        
        
    def send_to_clipboard(clip_type, data):
        if platform == "win32":
            if clip_type == "text":
                win32clipboard.OpenClipboard()
                win32clipboard.EmptyClipboard()
                win32clipboard.SetClipboardText(data)
                win32clipboard.CloseClipboard()
            else:
                win32clipboard.OpenClipboard()
                win32clipboard.EmptyClipboard()
                win32clipboard.SetClipboardData(clip_type, data)
                win32clipboard.CloseClipboard()
                
                


ok = ScreenShot()

ok.screenshot_monitor(monitor_number="0", filename="test", clipboard=True)