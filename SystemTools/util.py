import os
import subprocess
from sys import platform
from ast import literal_eval
import sounddevice as sd
import pyttsx3

if platform == "win32":
    from ctypes import windll
    import audio2numpy as a2n

def runWindowsCMD(command):
    systemencoding = windll.kernel32.GetConsoleOutputCP()
    systemencoding= f"cp{systemencoding}"
    output = subprocess.run(command, stdout=subprocess.PIPE, shell=True)
    result = str(output.stdout.decode(systemencoding))
    return result

class SystemPrograms:
    def __init__(self):
        self.programs = self.getSystemApp()
        self.steam = self.programs["SteamApps"]
        self.microsoft = self.programs['Microsoft']
        self.other = self.programs["OtherApps"]

    def getSystemApp(self):
        SteamsApps = {}
        OtherApps = {}
        Microsoft = {}

        programs = runWindowsCMD(["powershell", "get-StartApps | ConvertTo-Json"])
        programs = list(literal_eval(programs))

        for program in programs:
            if not program['Name'].lower() in ["readme", "documentation"]:
                if "steam://rungameid/" in program['AppID']:
                    SteamsApps[program['Name']] = program['AppID']
                elif "Microsoft." in program['AppID'] and ".AutoGenerated." not in program['AppID']:
                    Microsoft[program['Name']] = program['AppID']
                else:
                    OtherApps[program['Name']] = program['AppID']
        return {"SteamApps": SteamsApps, "Microsoft": Microsoft, "OtherApps": OtherApps}

    def start(self, appName, apptype):
        if self.programs[apptype].get(appName, False):
            runWindowsCMD("explorer shell:appsfolder\\" + self.programs[apptype][appName])

class Powerplan:
    def __init__(self):
        self.currentPPlan = {}
        self.powerplans = {}
        self.GetPowerplan()

    def GetPowerplan(self):
        powerplanResult = runWindowsCMD("powercfg -List")
        powerplanDict = {}

        for powerplan in powerplanResult.split("\n"):
            if ":" in powerplan:
                parsedData = powerplan.split(":")[1].split() # from "Power Scheme GUID: 381b4222-f694-41f0-9685-ff5bb260df2e  (Balanced) *" to ["381b4222-f694-41f0-9685-ff5bb260df2e", "(Balanced) *"]
                the_data = (parsedData[0])
                plan_name = (" ".join(parsedData[1:]))

                if "*" in plan_name:
                    plan_name = plan_name[plan_name.find("(") + 1: plan_name.find(")")]
                    self.powerplans[plan_name]=the_data

                    self.currentPPlan[plan_name]=the_data
                else:
                    plan_name = plan_name[plan_name.find("(") + 1: plan_name.find(")")]
                    self.powerplans[plan_name]=the_data
    
    def changeTo(self, pplanName):
        if self.powerplans.get(pplanName, False):
            runWindowsCMD(f"powercfg.exe /S {self.powerplans[pplanName]}")
            return True
        return False

def getAllVoices():
    engine = pyttsx3.init()
    return engine.getProperty('voices')

def getAllOutput_TTS2():
    audio_dict = {}
    for outputDevice in sd.query_hostapis(0)['devices']:
        if sd.query_devices(outputDevice)['max_output_channels'] > 0:
            audio_dict[sd.query_devices(device=outputDevice)['name']] = sd.query_devices(device=outputDevice)['default_samplerate']
    return audio_dict

def TextToSpeech(message, voicesChoics, volume=100, rate=100, output="Default"):
    engine = pyttsx3.init()
    voices = engine.getProperty('voices')
    engine.setProperty("volume", volume/100)
    engine.setProperty("rate", rate)
    for voice in voices:
        if voice.name == voicesChoics:
            engine.setProperty('voice', voice.id)
            print("Using", voice.name, "voices", voice)

    if output == "Default":
        engine.say(message)
    else:
        appdata = os.getenv('APPDATA')
        engine.save_to_file(message, rf"{appdata}/TouchPortal/Plugins/WinTools/speech.wav")
    engine.runAndWait()
    engine.stop()

    if output is not "Default":
        device = getAllOutput_TTS2()  ### can make this list returned a global + save that will pull it once and thats it?  instead of every time this action is called..which could be troublesome..
        sd.default.samplerate = device[output]
        sd.default.device = output +", MME"
        x,sr=a2n.audio_from_file(rf"{appdata}/TouchPortal/Plugins/WinTools/speech.wav")
        sd.play(x, sr, blocking=True)