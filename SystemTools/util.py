from p_imports import *
##   moved to screencapture.py  ### Screenshot Monitor Imports ###
##   moved to screencapture.py  import mss.tools  # may need to find another module for this due to linux/macOS
##   moved to screencapture.py  from PIL import Image
##   moved to screencapture.py  from io import BytesIO

# Port Audio Trouble Shooting
# not needed ?? from ctypes.util import find_library
# print(find_library('portaudio'))



""" 
According to my research this is the most reliable way and better than system.platform 
### MAC Examples     - os.name = 'posix'      /     platform.system = 'Darwin'       /   platform.release = '8.11.0'
### Linux Examples   - os.name = 'posix'     /      platform.system = 'Linux'       /    platform.release = '3.19.0-23-generic'
### Windows Examples - os.name = 'nt'       /       platform.system = 'Windows'    /     platform.release = '10'

                                          EXAMPLES                                      """
#PLATFORM_SYSTEM = platform.system()  # Windows / Darwin / Linux
from TPPEntry import PLATFORM_SYSTEM


"""
Fedora Example 
{'arch': ('64bit', 'ELF'),
 'machine': 'x86_64',
 'platform full': 'Linux-5.19.4-200.fc36.x86_64-x86_64-with-glibc2.35',
 'platform mac': ('', ('', '', ''), ''),
 'release': '5.19.4-200.fc36.x86_64',
 'system': 'Linux',
 'version': '#1 SMP PREEMPT_DYNAMIC Thu Aug 25 17:42:04 UTC 2022'}
"""



def runWindowsCMD(command):
    """ 
    Running a windows command using system level encoding
    """
    systemencoding = windll.kernel32.GetConsoleOutputCP()
    output = subprocess.run(command, stdout=subprocess.PIPE, shell=True)
    result = str(output.stdout.decode("cp{}".format(str(systemencoding))))
    return result


class SystemPrograms:
    def __init__(self):
        self.programs = self.getSystemApp()
        self.steam = self.programs["SteamApps"]
        self.microsoft = self.programs['Microsoft']
        self.other = self.programs["Other"]

    def getSystemApp(self):
        SteamsApps = {}
        OtherApps = {}
        Microsoft = {}

        programs = runWindowsCMD(
            ["powershell", "get-StartApps | ConvertTo-Json"])
        programs = list(literal_eval(programs))

        for program in programs:
            if not program['Name'].lower() in ["readme", "documentation"]:
                if "steam://rungameid/" in program['AppID']:
                    SteamsApps[program['Name']] = program['AppID']
                elif "Microsoft." in program['AppID'] and ".AutoGenerated." not in program['AppID']:
                    Microsoft[program['Name']] = program['AppID']
                else:
                    OtherApps[program['Name']] = program['AppID']
        return {"SteamApps": SteamsApps, "Microsoft": Microsoft, "Other": OtherApps}

    def start(self, appName, apptype):
        if self.programs[apptype].get(appName, False):
            command = "explorer shell:appsfolder\\" + \
                self.programs[apptype][appName]
            runWindowsCMD(command)




class Get_Windows:
    def get_windows_Windows_OS():
        results = []

        def winEnumHandler(hwnd, ctx):
            if win32gui.IsWindowVisible(hwnd):
                if win32gui.GetWindowText(hwnd):

                    results.append(win32gui.GetWindowText(hwnd))

        win32gui.EnumWindows(winEnumHandler, None)
        return results

    def get_windows_Linux():
        """ 
        This Includes the Current Active Window 
        - Docs -> https://lazka.github.io/pgi-docs/Wnck-3.0/classes/Window.html#Wnck.Window.get_class_group_name
        """
        import gi
        # It must be set to require 3.0 bfore we import Wnck
        gi.require_version("Wnck", "3.0")
        from gi.repository import Wnck

        scr = Wnck.Screen.get_default()

        # Force Update must be done
        scr.force_update()

   #     all_windows = scr.get_windows()
        # all_windows_list = [x for x in scr.get_windows()]

        window_name_list = []
        for x in scr.get_windows():
            window_name_list.append(x.get_name())

        """ Current Active Window Details"""
        ACTIVE_WINDOW_NAME = scr.get_active_window().get_name()
        ACTIVE_WINDOW_XID = scr.get_active_window().get_xid()
        ACTIVE_WINDOW_PID = scr.get_active_window().get_pid()

        return window_name_list




class ClipBoard:
    def copy_image_to_clipboard(image):
        if PLATFORM_SYSTEM == "Windows":
            bio = BytesIO()
            image.save(bio, 'BMP')
            data = bio.getvalue()[14:]  # removing some headers
            bio.close()
            ClipBoard.send_to_clipboard(win32clipboard.CF_DIB, data)

        # This currently works with Fedora 36 and saves image to clipboard
        if PLATFORM_SYSTEM == "Linux":
            memory = BytesIO()
            image.save(memory, format="png")
            output = subprocess.Popen(("xclip", "-selection", "clipboard", "-t", "image/png", "-i"),
                                      stdin=subprocess.PIPE)
            # write image to stdin
            output.stdin.write(memory.getvalue())
            output.stdin.close()

            # BACKUP OPTIONS
            # Option # 1
            # os.system(f"xclip -selection clipboard -t image/png -i {path + '/image.png'}")
            # os.system("xclip -selection clipboard -t image/png -i temp_file.png")

            # Option #2  - https://stackoverflow.com/questions/56618983/how-do-i-copy-a-pil-picture-to-clipboard
            # might be able to use module called klemboard ??

        # This needs tested/worked on...
        if PLATFORM_SYSTEM == "Darwin":
            # Option #1
            # os.system(f"pbcopy < {path + '/image.png'}")

            # Option #2

            subprocess.run(
                ["osascript", "-e", 'set the clipboard to (read (POSIX file "image.jpg") as JPEG picture)'])

    def send_to_clipboard(clip_type, data):
        if PLATFORM_SYSTEM == "Windows":
            if clip_type == "text":
                win32clipboard.OpenClipboard()
                win32clipboard.EmptyClipboard()
                win32clipboard.SetClipboardText(data)
                win32clipboard.CloseClipboard()
            else:
                win32clipboard.OpenClipboard()
                win32clipboard.EmptyClipboard()
                win32clipboard.SetClipboardData(clip_type, data)
                win32clipboard.CloseClipboard()


# ok = ScreenShot()
#
# ok.screenshot_monitor(monitor_number="0", filename="test", clipboard=True)
# import wx  ## apart of pyGUI ??  can this copy to clipboard on linux too ??  https://www.programcreek.com/python/?code=miloharper%2Fneural-network-animation%2Fneural-network-animation-master%2Fmatplotlib%2Fbackends%2Fbackend_wx.py
"""
def Copy_to_Clipboard(self, event=None):
    "copy bitmap of canvas to system clipboard"
    bmp_obj = wx.BitmapDataObject()
    bmp_obj.SetBitmap(self.bitmap)

    if not wx.TheClipboard.IsOpened():
        open_success = wx.TheClipboard.Open()
        if open_success:
            wx.TheClipboard.SetData(bmp_obj)
            wx.TheClipboard.Close()
            wx.TheClipboard.Flush()
"""
